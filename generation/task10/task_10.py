# -*- coding: utf-8 -*-
"""Task10.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zBuTMGIOhXF6ktYIJXOEytMb6TFNLP2G
"""

# -*- coding: utf-8 -*-
import numpy as np
import sympy as sp
    
def is_col(a, b):
      vec_mult = (a[1] * b[2] - a[2] * b[1], a[2]*b[0] - a[0]*b[2], a[0]*b[1] - a[1]*b[0])
      return vec_mult == (0,0,0)

class Task10:
    def __init__(self) -> None:
        pass

    def generate(self):
        eq1,eq2,eq3,eq4 = None,None,None,None
        canon1, canon2 = None, None
        
        while True:
            M1 = sp.Point3D(np.random.randint(-20,20), np.random.randint(-20,20), np.random.randint(-20,20)) # точка 1 перпендикуляра
            while True:
              n_12 = (np.random.randint(-20,20), np.random.randint(-20,20), np.random.randint(-20,20)) # нормаль двух плоскостей (направляющий перпендикуляра)
              if abs(n_12[0]) > 1 and abs(n_12[1]) > 1 and abs(n_12[2]) > 1:
                break


            a = np.random.randint(3,7) if np.random.randint(0,10) >= 5 else np.random.randint(-7,-3)
            M2 = M1 + a*sp.Point3D(*n_12) # на той же нормали 2 точка
            
            n4 = (np.random.randint(-20,20), np.random.randint(-20,20), np.random.randint(-20,20))
            n3 = (np.random.randint(-20,20), np.random.randint(-20,20), np.random.randint(-20,20))
            n2 = n_12
            n1 = (n2[0] + n3[0], n2[1] + n3[1], n2[2] + n3[2])

            if n1 == (0,0,0) or n2 == (0,0,0) or n3 == (0,0,0) or n4 == (0,0,0):
              continue
            
            if is_col(n1,n4) or is_col(n2,n3) or is_col(n2,n4) or is_col(n3,n4):
              continue
            
            P1 = sp.Plane(M1, n1)
            P2 = sp.Plane(M2, n2)
            P3 = sp.Plane(M1, n3)
            P4 = sp.Plane(M2, n4)
            eq1, eq2, eq3, eq4 = P1.equation(), P2.equation(), P3.equation(), P4.equation()
            break
        
        x,y,z = sp.symbols('x y z')
        canon1 = (sp.together(sp.S(x - M1.x) / sp.S(n_12[0])), sp.together(sp.S(y - M1.y) / sp.S(n_12[1])), sp.together(sp.S(z - M1.z) / sp.S(n_12[2])))
        latex_canon1 = sp.latex(canon1[0]) + ' = ' + sp.latex(canon1[1]) + ' = ' + sp.latex(canon1[2])
        canon2 = (sp.together(sp.S(x - M2.x) / sp.S(n_12[0])), sp.together(sp.S(y - M2.y) / sp.S(n_12[1])), sp.together(sp.S(z - M2.z) / sp.S(n_12[2])))
        latex_canon2 = sp.latex(canon2[0]) + ' = ' + sp.latex(canon2[1]) + ' = ' + sp.latex(canon2[2])

        task_text = 'Заданы две прямые $L_1$ и $L_2$ своими общими уравнениями ' \
                    f'$$L_1: \\begin{{cases}}' \
                    f'{sp.latex(eq1)} = 0\\\\ {sp.latex(eq3)} = 0\\\\' \
                    f'\\end{{cases}} \\hspace{{1cm}} ' \
                    f'L_2: \\begin{{cases}}' \
                    f'{sp.latex(eq2)} = 0\\\\ {sp.latex(eq4)} = 0\\\\ ' \
                    f'\\end{{cases}}$$' \
                    f'Написать каноническое уравнение прямой, являющейся общим перпендикуляром к $L_1$ и $L_2$.'

        answer_text = f'Возможная запись канонического уравнения прямой 1:' \
                      f'$${latex_canon1}$$\\\\' \
                      f'Возможная запись канонического уравнения прямой 2:' \
                      f'$${latex_canon2}$$'

        return task_text, answer_text